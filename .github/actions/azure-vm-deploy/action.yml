name: 'Deploy to Azure Windows VM'
description: 'Deploys application to Azure Windows VM using Azure VM Run Command (no WinRM required)'
author: 'Architecture Team'

inputs:
  keyvault-name:
    description: 'Azure Key Vault name for fetching secrets'
    required: true
  vm-name:
    description: 'Azure VM name'
    required: true
  resource-group:
    description: 'Azure resource group name'
    required: true
  deployment-package-path:
    description: 'Path to deployment package (zip file)'
    required: true
  deployment-script-path:
    description: 'Path to deployment PowerShell script'
    required: true
  iis-site-name:
    description: 'IIS site name'
    required: false
    default: 'Default Web Site'
  iis-app-name:
    description: 'IIS application name'
    required: false
    default: 'VBNetApp'
  iis-app-pool:
    description: 'IIS application pool name'
    required: false
    default: 'VBNetAppPool'
  environment:
    description: 'Deployment environment (dev/staging/prod)'
    required: false
    default: 'Production'

outputs:
  deployment-status:
    description: 'Deployment status (success/failure)'
    value: ${{ steps.deploy.outputs.status }}
  app-url:
    description: 'Application URL'
    value: ${{ steps.get-vm-info.outputs.app-url }}

runs:
  using: "composite"
  steps:
    - name: Fetch secrets from Azure Key Vault
      id: keyvault
      shell: pwsh
      env:
        KEYVAULT_NAME: ${{ inputs.keyvault-name }}
      run: |
        $connectionStrings = az keyvault secret show --vault-name $env:KEYVAULT_NAME --name "connection-strings" --query "value" -o tsv
        $apiKeys = az keyvault secret show --vault-name $env:KEYVAULT_NAME --name "api-keys" --query "value" -o tsv
        echo "::add-mask::$connectionStrings"
        echo "::add-mask::$apiKeys"
        echo "connection-strings=$connectionStrings" >> $env:GITHUB_OUTPUT
        echo "api-keys=$apiKeys" >> $env:GITHUB_OUTPUT

    - name: Get VM Information
      id: get-vm-info
      shell: pwsh
      env:
        RESOURCE_GROUP: ${{ inputs.resource-group }}
        VM_NAME: ${{ inputs.vm-name }}
        IIS_APP_NAME: ${{ inputs.iis-app-name }}
      run: |
        Write-Host "Getting VM information..."

        # Get VM details
        $vmInfo = az vm show -d `
          -g $env:RESOURCE_GROUP `
          -n $env:VM_NAME `
          --query "{publicIp:publicIps, privateIp:privateIps, powerState:powerState}" `
          -o json | ConvertFrom-Json

        Write-Host "VM Name: $($env:VM_NAME)"
        Write-Host "Power State: $($vmInfo.powerState)"
        Write-Host "Public IP: $($vmInfo.publicIp)"

        # Set outputs
        $appUrl = "http://$($vmInfo.publicIp)/$($env:IIS_APP_NAME)"
        echo "app-url=$appUrl" >> $env:GITHUB_OUTPUT
        echo "vm-public-ip=$($vmInfo.publicIp)" >> $env:GITHUB_OUTPUT

        if ($vmInfo.powerState -ne "VM running") {
          Write-Error "VM is not running. Current state: $($vmInfo.powerState)"
          exit 1
        }

    - name: Prepare deployment package for upload
      id: prepare
      shell: pwsh
      env:
        DEPLOYMENT_PACKAGE_PATH: ${{ inputs.deployment-package-path }}
        DEPLOYMENT_SCRIPT_PATH: ${{ inputs.deployment-script-path }}
      run: |
        # Generate unique deployment ID
        $deploymentId = "deploy-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
        echo "deployment-id=$deploymentId" >> $env:GITHUB_OUTPUT

        # Create temporary directory for deployment assets
        $tempDir = Join-Path $env:RUNNER_TEMP $deploymentId
        New-Item -ItemType Directory -Path $tempDir -Force | Out-Null

        # Copy deployment package
        $packageName = Split-Path -Leaf $env:DEPLOYMENT_PACKAGE_PATH
        Copy-Item -Path $env:DEPLOYMENT_PACKAGE_PATH -Destination "$tempDir\$packageName"

        # Copy deployment script
        $scriptName = Split-Path -Leaf $env:DEPLOYMENT_SCRIPT_PATH
        Copy-Item -Path $env:DEPLOYMENT_SCRIPT_PATH -Destination "$tempDir\$scriptName"

        echo "temp-dir=$tempDir" >> $env:GITHUB_OUTPUT
        echo "package-name=$packageName" >> $env:GITHUB_OUTPUT
        echo "script-name=$scriptName" >> $env:GITHUB_OUTPUT

        Write-Host "Deployment assets prepared in: $tempDir"

    - name: Upload deployment package to VM
      shell: pwsh
      env:
        RESOURCE_GROUP: ${{ inputs.resource-group }}
        VM_NAME: ${{ inputs.vm-name }}
      run: |
        Write-Host "Uploading deployment package to VM..."

        # Create deployment directory on VM
        $createDirScript = @'
        if (-not (Test-Path "C:\Deploy")) {
            New-Item -ItemType Directory -Path "C:\Deploy" -Force
        }
'@

        az vm run-command invoke `
          --resource-group $env:RESOURCE_GROUP `
          --name $env:VM_NAME `
          --command-id RunPowerShellScript `
          --scripts $createDirScript

        Write-Host "Deployment directory created on VM"

    - name: Execute deployment via Azure VM Run Command
      id: deploy
      shell: pwsh
      env:
        VM_NAME: ${{ inputs.vm-name }}
        RESOURCE_GROUP: ${{ inputs.resource-group }}
        DEPLOYMENT_SCRIPT_PATH: ${{ inputs.deployment-script-path }}
        DEPLOYMENT_PACKAGE_PATH: ${{ inputs.deployment-package-path }}
        PACKAGE_NAME: ${{ steps.prepare.outputs.package-name }}
        IIS_SITE_NAME: ${{ inputs.iis-site-name }}
        IIS_APP_NAME: ${{ inputs.iis-app-name }}
        IIS_APP_POOL: ${{ inputs.iis-app-pool }}
        DEPLOY_ENVIRONMENT: ${{ inputs.environment }}
        KV_CONNECTION_STRINGS: ${{ steps.keyvault.outputs.connection-strings }}
        KV_API_KEYS: ${{ steps.keyvault.outputs.api-keys }}
      run: |
        Write-Host "Executing deployment on Azure VM via VM Run Command..."
        Write-Host "VM: $($env:VM_NAME)"
        Write-Host "Resource Group: $($env:RESOURCE_GROUP)"
        Write-Host "Package: $($env:PACKAGE_NAME)"

        # Read deployment script
        $deployScript = Get-Content -Path $env:DEPLOYMENT_SCRIPT_PATH -Raw

        # Prepare deployment parameters
        $packagePath = "C:\Deploy\$($env:PACKAGE_NAME)"
        $siteName = $env:IIS_SITE_NAME
        $appName = $env:IIS_APP_NAME
        $appPoolName = $env:IIS_APP_POOL
        $deployEnv = $env:DEPLOY_ENVIRONMENT

        # Build configuration tokens (from Key Vault secrets)
        $configTokens = @{
          "CONNECTION_STRING" = $env:KV_CONNECTION_STRINGS
          "API_KEY" = $env:KV_API_KEYS
        }

        # Create wrapper script that calls deployment script with parameters
        $wrapperScript = @"
# Upload deployment package content (base64 encoded)
`$packageContent = [System.Convert]::FromBase64String('$(
  [Convert]::ToBase64String([System.IO.File]::ReadAllBytes($env:DEPLOYMENT_PACKAGE_PATH))
)')
[System.IO.File]::WriteAllBytes('$packagePath', `$packageContent)

Write-Host "Package uploaded to: $packagePath"

# Execute deployment script
$deployScript

# Execute deployment function
try {
    & {
        param(`$PackagePath, `$SiteName, `$AppName, `$AppPoolName, `$CreateBackup, `$Environment, `$ConfigTokens)
        # Script content already loaded above
    } -PackagePath '$packagePath' ``
      -SiteName '$siteName' ``
      -AppName '$appName' ``
      -AppPoolName '$appPoolName' ``
      -CreateBackup `$true ``
      -Environment '$deployEnv' ``
      -ConfigTokens @{ CONNECTION_STRING='$($configTokens.CONNECTION_STRING)'; API_KEY='$($configTokens.API_KEY)' }
} catch {
    Write-Error "Deployment failed: `$_"
    exit 1
}
"@

        # Execute deployment via VM Run Command
        Write-Host "Invoking VM Run Command..."

        $result = az vm run-command invoke `
          --resource-group $env:RESOURCE_GROUP `
          --name $env:VM_NAME `
          --command-id RunPowerShellScript `
          --scripts $wrapperScript `
          --output json | ConvertFrom-Json

        # Check result
        if ($result.value[0].message -match "Deployment Completed Successfully") {
          Write-Host "Deployment completed successfully!"
          echo "status=success" >> $env:GITHUB_OUTPUT
        } else {
          Write-Error "Deployment may have failed. Check output below:"
          Write-Host $result.value[0].message
          echo "status=failure" >> $env:GITHUB_OUTPUT
          exit 1
        }

        # Output deployment logs
        Write-Host "`n========== Deployment Output =========="
        Write-Host $result.value[0].message
        Write-Host "======================================`n"

    - name: Health check
      shell: pwsh
      env:
        APP_URL: ${{ steps.get-vm-info.outputs.app-url }}
      run: |
        Write-Host "Performing health check..."
        Write-Host "Application URL: $($env:APP_URL)"

        # Wait a few seconds for IIS to start
        Start-Sleep -Seconds 5

        try {
          $response = Invoke-WebRequest -Uri $env:APP_URL -UseBasicParsing -TimeoutSec 30
          if ($response.StatusCode -eq 200) {
            Write-Host "Health check passed! Application is accessible."
          } else {
            Write-Warning "Health check returned status code: $($response.StatusCode)"
          }
        } catch {
          Write-Warning "Health check failed: $_"
          Write-Host "Application may still be starting up. Manual verification recommended."
        }

    - name: Output deployment summary
      shell: pwsh
      env:
        VM_NAME: ${{ inputs.vm-name }}
        RESOURCE_GROUP: ${{ inputs.resource-group }}
        IIS_SITE_NAME: ${{ inputs.iis-site-name }}
        IIS_APP_NAME: ${{ inputs.iis-app-name }}
        DEPLOY_ENVIRONMENT: ${{ inputs.environment }}
        APP_URL: ${{ steps.get-vm-info.outputs.app-url }}
        DEPLOY_STATUS: ${{ steps.deploy.outputs.status }}
      run: |
        Write-Host "`n========== Deployment Summary =========="
        Write-Host "VM: $($env:VM_NAME)"
        Write-Host "Resource Group: $($env:RESOURCE_GROUP)"
        Write-Host "IIS Site: $($env:IIS_SITE_NAME)"
        Write-Host "Application: $($env:IIS_APP_NAME)"
        Write-Host "Environment: $($env:DEPLOY_ENVIRONMENT)"
        Write-Host "Application URL: $($env:APP_URL)"
        Write-Host "Status: $($env:DEPLOY_STATUS)"
        Write-Host "========================================"
